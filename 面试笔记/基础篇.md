
- [浏览器](#浏览器)
  - [浏览器缓存](#浏览器缓存)
    - [强制缓存](#强制缓存)
      - [Cache-Control](#cache-control)
    - [协商缓存](#协商缓存)
  - [cookie和web Storage](#cookie和web-storage)
    - [cookie](#cookie)
    - [web Storage](#web-storage)
  - [get和post](#get和post)
  - [Window.onload与jq的ready区别](#windowonload与jq的ready区别)
  - [同源策略（跨域）](#同源策略跨域)
  - [HTTP的报文header](#http的报文header)
  - [谈谈HTTPS](#谈谈https)
  - [什么是Xss](#什么是xss)
  - [什么是CSRF](#什么是csrf)
- [js部分](#js部分)
  - [ES6 的 class 和构造函数的区别](#es6-的-class-和构造函数的区别)
  - [解释什么是原型链](#解释什么是原型链)
  - [JSON.stringify](#jsonstringify)
  - [typeof](#typeof)
    - [typeof对null显示object](#typeof对null显示object)
  - [Object.defineProperty 与 Proxy](#objectdefineproperty-与-proxy)

# 浏览器

## 浏览器缓存

### 强制缓存

#### Cache-Control

> 资料：<https://juejin.cn/post/6844903751493369870>

通用的首部字段，控制缓存。在请求中使用 Cache-Control 主要是告诉服务器如何处理缓存，而在响应中使用 Cache-Control 则是告诉客户端如何处理缓存

**请求首部**Cache-Control的值

- no-cache

  在请求头部中使用 no-cache 可以告诉服务端不要直接从缓存中返回响应，而是需要先向服务器验证资源是否过期或者是否有更新
  
- no-store
  
  在请求头部中使用 no-store 可以告诉服务端不要返回经过缓存的响应，而是每次都重新生成响应
  
- min-fresh
  
  设定能够容忍的最小新鲜度（缓存时长）。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。
  
- no-transform<a id='transform'></a>
  表示不允许代理服务器对响应的实体部分进行内容编码或者类型转换。这个指令可以确保客户端能够获得与服务器原始响应相同的内容，避免了由于代理服务器对响应内容的修改导致的数据损坏、安全问题或其他异常情况。需要注意的是，no-transform 只对中间代理服务器（如 CDN 缓存、反向代理等）有效，而对终端用户代理（如浏览器）无效。
  
  no-transform 指令的作用主要是保证内容的完整性和一致性，避免了缓存或代理服务器可能会对内容进行意外或恶意修改的情况。一些特殊的内容，如加密数据、数字签名等，可能需要采用 no-transform 指令来确保其正确性和安全性。
  
  需要注意的是，使用 no-transform 指令可能会降低缓存利用率和网络传输效率，因为缓存或代理服务器无法对内容进行压缩和优化处理。因此，在具体应用场景中需要权衡安全性和性能之间的关系来选择是否使用 no-transform 指令。

- only-if-cached

  用于指示客户端只接受已经缓存过的响应，如果请求的资源在缓存中不存在，则返回 504 Gateway Timeout 错误。这个指令可以减少网络传输，提高性能，适用于那些实时性要求不高、但是需要频繁读取相同内容的场景。

- max-age
  
  max-age指令标示了客户端不愿意接收一个age大于设定时间的响应，这个字段表达是最大缓存时长，请求中单单添加这个字段，实现不了缓存时长，必须结合[响应的max-age](#max-age)

**响应首部**Cache-Control的值

- no-cache
  
  在响应头部中使用 no-cache 可以告诉客户端不得将服务端返回的响应内容存储在本地缓存中。因此，no-cache 是 Cache-Control 请求头部和响应头部字段均可用的指令。

- no-store
  
  在响应头部中使用 no-store 可以告诉客户端不得将服务端返回的响应内容存储在本地缓存中，每次都需要从服务端重新获取

- public
  
  用于标记响应可以被任意缓存（比如 CDN、代理等）缓存。当使用 public 指令时，所有的缓存都可以缓存并返回响应给下一次请求相同资源的客户端，即使这些客户端与原始请求的客户端之间并没有共享缓存。public 指令可以有效提高缓存利用率，加速网络传输，降低服务器负载，适用于那些静态不变资源，且需要被多个客户端访问的场景。需要注意的是，使用 public 指令会将响应暴露给公共网络，因此在涉及敏感信息或者希望保持安全性的场景中应该避免使用该指令。与 public 相反的是 private 指令，它用于指示响应只能被特定的客户端缓存，不能被其他缓存或者代理服务器缓存。

- private
  
  用于标记响应只能被特定的客户端或者用户缓存，不能被其他公共缓存（比如 CDN、代理等）或者代理服务器缓存。当使用 private 指令时，响应被缓存时需要加上一个私有标识符（如用户账号、会话 ID 等）来确保响应只能被该标识符对应的客户端或用户所缓存，其他客户端或用户无法访问该响应。private 指令可以保护敏感信息和数据隐私，适用于那些需要用户认证或授权才能访问的资源。

- no-transform
  
  [同请求](#transform)

- max-age <a id='max-age' ></a>

  在Response中设置max-age的时间信息，可以在客户端生成缓存文件，在缓存不过期的情况下，客户端不会直接向服务器请求数据，在缓存过期的情况下，客户端会向服务器直接请求生成新的缓存。
  
  如果同时设置了Response和Request中的max-age 缓存时间，如果Request中的max-age时间小于Response中的max-age时间，客户端会根据Request中max-age时间周期去直接进行网络请求，如果碰到断网或者网络请求不通的情况，即使缓存还在有效期内（Response中设置的max-age时间足够大），在Request设置的max-age过期之后，APP也会直接去进行网络请求。 因此可以考虑在客户端的设计中一个和好的网络缓存场景，用Response的max-age控制缓存的时间，用Request中max-age控制刷新的时间和机制
  
  **应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略**

- s-max-age

  是专门针对共享缓存（比如 CDN、代理等）而设计的缓存控制指令。与 max-age 指令类似s-max-age 也用于指示共享缓存服务器在缓存响应时可以保留响应数据的最长时间，从而提高网络传输效率和用户体验。

  与 max-age 不同的是，s-max-age 仅适用于共享缓存服务器，而不适用于私有缓存或浏览器缓存。当使用 s-max-age 指令时，缓存服务器会忽略其他所有 Cache-Control 指令，而只依据 s-max-age 指令来缓存响应。因此，s-max-age 指令可以用于强制所有共享缓存服务器遵循相同的缓存策略，从而确保响应数据的一致性和正确性，减少由缓存导致的数据损坏或混淆。

  如果同时指定了 max-age 和 s-max-age，则以 s-max-age 指令的值为准。

- must-revalidate
  
  使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。

- proxy-revalidate

  指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。

### 协商缓存
<!-- 
浏览器缓存可以将一些资源如html、脚本保存在**内存**中。浏览器缓存主要可以分为：强制缓存和协商缓存。

- **三级缓存原理 (访问缓存优先级)**

> 1、先在内存中查找,如果有,直接加载。  
> 2、如果内存中不存在,则在硬盘中查找,如果有直接加载。  
> 3、如果硬盘中也没有,那么就进行网络请求。  
> 4、请求获取的资源缓存到硬盘和内存。  

- **强制缓存**

  - 1、Expires

    该字段是 http1.0 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。  

    **存在问题：**  
    由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

  - 2、Cache-Control

    Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：

    - no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
    - no-store：禁止使用缓存，每一次都要重新请求数据。
    - public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
    - private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

    **注意** Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。

- **协商缓存**

  - 1、Last-Modify/If-Modify-Since：

    浏览器第一次请求一个资源的时候，服务器在返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。当浏览器再次请求该资源时request 的请求头中会包含 If-Modify-Since（之前返回的 Last-Modify），服务器判断是否有修改。在缓存中，则返回304，并且不会返回资源内容和Last-Modify。

    **存在问题：**

    - a、有些问题内容没有变，只是修改了时间，客户端也会重新获取；
    - b、If-Modify-Since只能检测到秒级

  - 2、ETag/If-None-Match：

    浏览器第一次请求一个资源的时候，服务器在返回的 header 中会加上 ETag。浏览器再次请求该资源时request 的请求头中会包含 If-None-Match（之前返回的 ETag）服务器判断是否有修改。在缓存中，服务器将If-None-Match的值设为false，返回状态为304。

    **注意**协商缓存会优先对比ETag，一致时才会比较Last-Modify

    参考：<https://segmentfault.com/a/1190000017962411> -->

## [cookie](https://mp.weixin.qq.com/s/K8suxBZQvhoHNPo70BTHZg)和web Storage

### cookie

存储空间较少，可以设置过期时间，可以跨二级域名，每次请求都会带上

- 值
  SameSite 可以有下面三种值：

  - Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
  - Lax 允许部分第三方请求携带 Cookie
  - None 无论是否跨站都会发送 Cookie

  Secure属性

  标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改

[cookie 和 token 都存放在 header 中，为什么不会劫持 token？](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31)

### web Storage

存储空间较大，永久存储，不可以跨二级域名

## get和post

get：是从服务器上获取数据，回退时是无害的, 传送的数据量较小，不能大于2KB，安全性非常低，接受ASCII字符，请求参数会被完整保留在历史记录里，只能进行url编码

post：是向服务器传送数据，传送的数据量较大，安全性较高，支持多种编码方式，

## Window.onload与jq的ready区别

onload：必须等待网页中所有的内容加载完毕后 ( 包括图片 ) 才能执行, 绑定多个，只会执行最后一个绑定的函数  
ready：等待网页中所有的内容加载完毕后 ( 不包括图片 ) 才能执行，可以绑定多个函数  

## 同源策略（跨域）

同源指协议，域名，端口相同的网站，同源策略限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。如果非同源，共有三种行为受到限制。浏览器会限制不同协议、域名和端口的网站，文档资源之间的交互

> （1） Cookie、LocalStorage 和 IndexDB 无法读取。  
> （2） DOM 无法获得。  
> （3） AJAX 请求不能发送。  

- 1、Cookie、LocalStorage 和 IndexDB规避

> Cookie可以通过设置document.domain或服务器设置Cookie的domain字段，前者只适用于二级域名，二者可用于三级域名。Cookie  
> LocalStorage和 IndexDB：postMessage  

- 2、iframe规避

> 片段识别符: 父域通过#+data的形式向子域传递数据，数据有限，不安全  
> window.name: 容量很大, 影响性能，能保存字符串  
> postMessage  

- 3、AJAX规避

> 1、JSONP: 利用script标签没有跨域限制，向页面插入一个新的script，请求跨域数据。JSONP本质上并不是AJAx且只能是get请求。  
> 2、CORS：使用范围IE浏览器不能低于IE10，浏览器和服务器同时支持。（1）简单请求：浏览器请求是会在http头部增加一个Origin字段用来说明本次请求来自哪个源，服务器根据这个值，决定是否同意这次请求，放回Access-Control-Allow-Origin。（2）非简单请求：会在请求前增加一次OPTIONS（带上Origin字段）查询请求，服务器根据这个值，决定是否同意这次请求，放回Access-Control-Allow-Origin。一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，与简单请求一样

跨域携带cookie需要设置withCredentials=true

<!-- # HTTP的三次挥手

其中比较重要的字段有：
（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：

URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接。 -->

## HTTP的报文header

> 1、Cache-Control: 控制缓存  
> 2、Date: 创建报文的日期  
> 3、If-Match: 在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag值时才会返回资源。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。  

## 谈谈HTTPS

我们通常会对敏感信息进行加密处理，加密方式一般是将对称加密的密钥使用非对称加密，然后客户端使用公钥解密得到密钥，只用使用密钥对敏感信息进行加密处理。但是服务器向客户端发送公钥可能被劫持。所以需要一个安全的第三方（CA）颁发证书+数字签名。证书中包括：使用者公钥、使用者私钥等。CA会用自带的hash算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。当别人把他的证书发过来的时候, 我再用同样的Hash算法, 再次生成消息摘要，然后用CA的公钥对数字签名解密, 得到CA创建的消息摘要

参考：<https://juejin.im/post/5d032b77e51d45777a126183##heading-13>

参考：<https://juejin.im/post/592d23630ce46300579882b4>

## 什么是Xss

Xss既跨站脚本攻击，指攻击者在网页上恶意注入脚本代码，获取用户的隐私，如：cookie、session。解决：

- 1、使用HttpOnly禁止页面的Javascript访问带有HttpOnly属性的Cookie。 防止劫取Cookie
- 2、对用户的输入做校验，过滤 < 、>、script。
- 3、使用.innerHTML、.outerHTML、document.write，不要将不信任的数据

> <https://juejin.cn/post/6844904179182354439>
>
## 什么是CSRF

CSRF即跨站请求伪造，通常是指攻击者借助用户的cookie向服务器发送请求，代替用户执行一些敏感操纵。解决：  

- 1、验证码，强制用户必须与应用进行交互  
- 2、使用 Referer，检查请求是否来自合法的"源"。  
- 3、添加token验证  

> <https://juejin.cn/post/6844904180918779918>
>
# js部分

## [ES6 的 class 和构造函数的区别](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20)

- 1、class 不会声明提升。
- 2、class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
- 3、class 声明内部会启用严格模式。
- 4、class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
- 5、必须使用 new 调用 class。
- 6、class可以继承静态方法，而构造函数不能  

  ```js
  function fun(){}
  fun.test=()=>{}// 静态方法
  ```

- 7、继承的差异

  ```js
  class Super {}
  class Sub extends Super {}
  const sub = new Sub();
  Sub.__proto__=== Super;

  ```

  子类可以直接通过 **proto** 寻址到父类。

  ```js
  function Super() {}
  function Sub() {}

  Sub.prototype = new Super();
  Sub.prototype.constructor = Sub;

  var sub = new Sub();
  Sub.__proto__ === Function.prototype;
  ```

  而通过 ES5 的方式，Sub.**proto** === Function.prototype

## 解释什么是原型链

- constructor属性：原型对象有一个constructor属性，**指向该原型对象对应的构造函数**；由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数

  ```js
  function Foo(){};
  var f1 = new Foo;
  console.log(Foo.prototype.constructor === Foo);//true
  console.log(f1.constructor === Foo);//true
  ```

- __proto__属性（隐似）：对象和函数都有，指向对象的构造函数(constructor属性)的原型对象。
- prototype属性（显示）：函数才有，指向函数的原型对象

举例说明： 当我们去调用一个空对象或者一个函数的toString方法，并不会报错。 虽然他们自身没有这个方法，但是在原型链上是存在的。空对象上的__proto__属性指向对象的构造函数的原型对象，即Object（构造对象的构造函数）的prototype(原型对象)。函数则是先去查找原型对象，再去查找原型对象的__proto__属性。如果在函数的prototype上添加一个toString，当实例化函数时，实例的toString方法是我们新增的那个toString方法。

```js
a={},function func(){}
a.__proto__===fun.prototype.__proto__===Object.prototype //true
Function.prototype===fun.__proto__ //true
a.__proto__.toString===fun.prototype.__proto__.toString===Object.prototype.toString
func.prototype.toString=()=>"1"
b=new fun()
b.toString() // 1
```

> <https://www.cnblogs.com/xiaohuochai/p/5721552.html>

## JSON.stringify

> <https://juejin.cn/post/7072122968087724046>

- JSON.stringify方法只会序列化对象中可枚举的自有属性
- 数字Infinity和NaN以及null都被认为null
- 如果值有toJSON()方法，它负责定义哪些数据将被序列化。
- 出现在非数组对象属性值中: undefined、任意函数、Symbol 值在序列化过程中将会被忽略
- 出现在数组中: undefined、任意函数、Symbol值会被转化为 null
- 单独转换时: 会返回 undefined

  ```js
  console.log(JSON.stringify(undefined))  // undefined
  console.log(JSON.stringify(Symbol(111))) // undefined
  console.log(JSON.stringify(function sayHello() { 
    console.log('hello world')
  })) // undefined
  ```

- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值
- 尝试去转换 BigInt 类型的值会抛出 TypeError
- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误

```js
const obj = {
  a: 3,
  b: 4,
  c: null,
  d: undefined,
  get e () {}
}

console.log(JSON.stringify(obj))//{"a":3,"b":4,"c":null}

const d = {
    name: "卡卡则速网",
    toJSON() {
      return "JSON.stringify"
    }
  }
console.log(JSON.stringify(d))//'"JSON.stringify"'

```

## typeof

- 对于原始类型，除 null 都可以正确判断；对于引用类型，除 function 外，都会返回 "object"
- 可以返回7种数据类型：number、string、boolean、undefined、object、function ，以及 ES6 新增的 symbol
- typeof 未定义的变量不会报错，返回 "undefiend"

  ```js
  typeof a // 'undefined'
  ```

- typeof 返回值为 string 格式，注意类似这种考题: typeof(typeof(undefined)) -> "string"
- typeof(NaN) -> "number"

### typeof对null显示object

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object

```js
typeof null//object
```

## Object.defineProperty 与 Proxy

Object.defineProperty设置了 configurable 为 false 的属性无法进行代理。Object.defineProperty能够劫持`对象的属性`，但是需要对对象的每一个属性进行遍历劫持；如果对象上有新增的属性，则需要对新增的属性再次进行劫持；如果属性是对象，还需要深度遍历。数组的新增也不能劫持。

1、代理的粒度不同

defineProperty 只能代理属性，Proxy 代理的是对象。如果想代理对象的所有属性defineProperty 需要遍历属性一个个加 setter 和 getter。而 Proxy 只需要配置一个可以获取属性名参数的函数即可。

2、破坏原对象

defineProperty 的代理行为是在破坏原对象的基础上实现的，它通常会将原本的 value 变成了 setter 和 getter。Proxy 则不会破坏原对象，只是在原对象上覆盖了一层

3、代理范围

defineProperty 只能代理属性的 get 和 set。Proxy 还能代理其他的行为。（has，apply，call）
