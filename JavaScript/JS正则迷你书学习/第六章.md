- [第六章](#第六章)
  - [6.1 平衡法则](#61-平衡法则)
  - [6.2 构建正则前提](#62-构建正则前提)
    - [6.2.1. 是否能使用正则？](#621-是否能使用正则)
    - [6.2.2. 是否有必要使用正则？](#622-是否有必要使用正则)
    - [6.2.3. 是否有必要构建一个复杂的正则？](#623-是否有必要构建一个复杂的正则)
  - [6.3. 准确性](#63-准确性)
  - [6.4. 效率](#64-效率)
  - [6.4.1. 使用具体型字符组来代替通配符，来消除回溯](#641-使用具体型字符组来代替通配符来消除回溯)
    - [6.4.2. 使用非捕获型分组](#642-使用非捕获型分组)
    - [6.4.3. 独立出确定字符](#643-独立出确定字符)
    - [6.4.4. 提取分支公共部分](#644-提取分支公共部分)

# 第六章

## 6.1 平衡法则

构建正则有一点非常重要，需要做到下面几点的平衡：
匹配预期的字符串 不匹配非预期的字符串
可读性和可维护性
效率

## 6.2 构建正则前提

### 6.2.1. 是否能使用正则？

正则很强大，不要遇到字符就想使用正则

### 6.2.2. 是否有必要使用正则？

**_能用字符串 API 解决的简单问题，就不该正则出马。_**比如，从日期中提取出年月日，虽然可以使用正则：

```javascript
var string = "2017-07-01";
// bad
var regex = /^(\d{4})-(\d{2})-(\d{2})/;
//good
var result = string.split("-");
```

```javascript
var string = "?id=xx&act=search";
// bad
string.search(/\?/)
//good
string.indexOf("?")
```

### 6.2.3. 是否有必要构建一个复杂的正则？

比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字
符。

```javascript
/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/
```

其实可以使用多个小正则来做：

```javascript
var regex1 = /^[0-9A-Za-z]{6,12}$/;
var regex2 = /^[0-9]{6,12}$/;
var regex3 = /^[A-Z]{6,12}$/;
var regex4 = /^[a-z]{6,12}$/;
function checkPassword (string) {
  if (!regex1.test(string)) return false;
  if (regex2.test(string)) return false;
  if (regex3.test(string)) return false;
  if (regex4.test(string)) return false;
  return true; }
```

PS：个人觉得提高了可读性

## 6.3. 准确性

确认匹配的规则的准确性

## 6.4. 效率

保证了准确性后，才需要是否要考虑要优化。**大多数情形是不需要优化的，除非运行的非常慢**。

## 6.4.1. 使用具体型字符组来代替通配符，来消除回溯

如，匹配字符串 123"abc"456 中的 "abc"。

```javascript
// bad
/".*"/
// good，消除了3次回溯
/"[^"]*"/   

```

### 6.4.2. 使用非捕获型分组

因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。
当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。 例如，/^[-]?(\d\.\d+|\d+|\.\d+)$/ 可以修改成：/^[-]?(?:\d\.\d+|\d+|\.\d+)$/。

### 6.4.3. 独立出确定字符

例如，/a+/ 可以修改成 /aa*/。 因为后者能比前者多确定了字符 "a"。这样会在第四步中，加快判断是否匹配失败，进而加快移位的速度。

### 6.4.4. 提取分支公共部分

比如，/^abc|^def/ 修改成 /^(?:abc|def)/。 又比如， /this|that/修改成 /th(?:is|at)/。 这样做，可以减少匹配过程中可消除的重复。

 6.4.5. 减少分支的数量，缩小它们的范围
/red|read/ 可以修改成 /rea?d/。
此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。###
