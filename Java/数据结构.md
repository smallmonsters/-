# 数据结构

- [数据结构](#数据结构)
  - [堆（Heap）](#堆heap)
    - [数据结构中的堆和内存中的堆区别](#数据结构中的堆和内存中的堆区别)
  - [栈（Stack）](#栈stack)
    - [数据结构的栈和内存中的栈区别](#数据结构的栈和内存中的栈区别)
  - [队列（Queue）](#队列queue)
    - [ArrayDeque实现类](#arraydeque实现类)
  - [堆栈（Stack Heap）](#堆栈stack-heap)
  - [数组](#数组)
  - [链表](#链表)
    - [LinkedList实现类](#linkedlist实现类)
  - [Map](#map)
    - [HashMap实现类](#hashmap实现类)
    - [TreeMap实现类](#treemap实现类)
    - [LinkedHashMap实现类](#linkedhashmap实现类)
    - [ConcurrentHashMap实现类](#concurrenthashmap实现类)

## 堆（Heap）

堆是一种数据结构，用于维护具有优先级的元素集合。堆数据结构中，每个节点都有一个关键字，而且满足一定的堆性质，即父节点的关键字比子节点的关键字大（或小）。堆通常是一棵完全二叉树，可以使用数组来表示，也可以使用指针来实现。

>ps: 注意与内存中的堆的区别。一种动态分配的内存空间，用于存储对象。堆是一种非常灵活的数据结构，可以动态地分配和释放内存，因此非常适合存储变量和数据结构。在Java中，所有的对象都是存储在堆中的。

### 数据结构中的堆和内存中的堆区别

- 堆的定义不同：在数据结构中，堆是一种基于二叉树的数据结构，用于维护具有优先级的元素集合；而在内存中，堆是一种动态分配的内存空间，用于存储动态创建的对象。
- 数据结构中的堆是一种逻辑结构，而内存中的堆是一种物理结构。数据结构中的堆通过指针等逻辑关系实现，而内存中的堆通过物理地址实现。
- 数据结构中的堆通常是一个完全二叉树，具有一定的结构性质，而内存中的堆没有特定的结构要求，只需要满足动态分配、动态释放的需求。
- 数据结构中的堆通常是静态创建的，而内存中的堆是动态分配的，即在程序运行时根据需要分配内存空间。

总之，虽然数据结构中的堆和内存中的堆都称为“堆”，但它们是不同的概念，应该在使用时明确区分。数据结构中的堆是一种特殊的树形数据结构，用于维护具有优先级的元素集合；而内存中的堆是一种动态分配的内存空间，用于存储动态创建的对象。

## 栈（Stack）

栈是一种后进先出（Last In First Out，LIFO）的数据结构。栈中的元素只能从栈顶进出，也就是说，最后进入栈的元素最先被取出。栈通常用于实现递归调用和表达式求值。

- 只能从栈顶进行插入和删除操作。
- 栈的插入和删除操作的时间复杂度均为O(1)。
- 栈可以通过数组和链表来实现。

### 数据结构的栈和内存中的栈区别

- 定义不同：在数据结构中，栈是一种线性数据结构，用于实现“后进先出”的数据存储方式；在计算机科学中，内存中的栈是一种特殊的内存空间，用于存储函数调用的执行信息和局部变量等。
- 使用方式不同：在数据结构中，栈是一种抽象的数据结构，可以用数组或链表等方式实现，用于实现栈的基本操作，如push、pop、top等。而在计算机科学中，内存中的栈是一种物理的内存空间，由操作系统进行管理，主要用于存储函数调用的执行信息和局部变量等。
- 存储方式不同：在数据结构中，栈通常是用数组或链表等数据结构来实现的；而在计算机科学中，内存中的栈通常是由操作系统分配的一段连续的内存空间，具有一定的大小限制。
- 内容不同：在数据结构中，栈通常是用于存储一组数据元素，如整数、浮点数、字符串等；而在计算机科学中，内存中的栈主要用于存储函数调用的执行信息和局部变量等，不是存储数据元素的数据结构。

数据结构中的栈是一种抽象的数据结构，用于存储数据元素；而内存中的栈是一种物理的内存空间，用于存储函数调用的执行信息和局部变量等

## 队列（Queue）

队列是一种先进先出（First In First Out，FIFO）的数据结构。队列中的元素只能从队列头部进出，也就是说，最先进入队列的元素最先被取出。队列通常用于实现广度优先搜索和任务调度等。

### ArrayDeque实现类

一个基于数组实现的双端队列，可以作为栈或队列使用。

## 堆栈（Stack Heap）

堆栈是指同时使用堆和栈的数据结构。在Java中，每个线程都有自己的栈，用于存储方法调用和局部变量。而所有的对象都存储在堆中。因此，Java中的堆栈通常用于管理线程和存储对象。

## 数组

它是一种线性数据结构，使用一组连续的内存空间存储一组具有相同类型的数据。数组是用连续内存空间存储相同类型的元素，就是因为有这个限制条件，使得数组按照下标随机访问(随机访问：可以用同等的时间访问到一组数据中的任意一个元素)数组中数据元素时间复杂度达到 O(1) 级别。当然这样的限制也有缺点，在头部或者中间进行数据删除、插入操作时，为了保证这个连续性，需要对数据进行大量的复制迁移来保持此特性。

## 链表

它也是一种线程数据结构，与数组不同的是，它在内存空间中不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始（单链表），它的时间复杂度是O(n)。

Java 中的链表通常分为单向链表、双向链表和循环链表三种类型。

- 单向链表：每个节点只包含一个指向下一个节点的指针，不能向前访问。通常包含一个头结点和一个尾节点，头结点指向链表的第一个节点，尾节点指向链表的最后一个节点。
- 双向链表：每个节点包含一个指向前一个节点和一个指向后一个节点的指针。双向链表可以向前和向后访问，可以快速地实现在任意位置插入或删除节点。
- 循环链表：最后一个节点的指针指向第一个节点，形成一个环形结构。循环链表可以实现循环访问，遍历整个链表需要在指定的位置结束。

链表相比于数组，具有以下优点：

- 插入和删除操作快：由于链表是一种动态结构，可以很方便地进行节点的插入和删除操作。
- 空间利用率高：链表不需要预先分配固定大小的空间，而是根据实际需要动态分配空间，因此空间利用率比数组高。
- 可扩展性好：由于链表的动态特性，可以轻松地扩展链表的长度。

需要注意的是，链表的访问速度相对于数组来说比较慢，因为链表中的每个节点需要占用额外的空间来存储指针信息。另外，由于链表是一种动态结构，也需要额外的空间来存储指针信息，因此空间开销也比数组大。

### LinkedList实现类

- 一个双向链表，可以作为队列或栈使用。
- LinkedList 实现了 List 接口和 Deque 接口，可以被视为一个双向队列（Deque）和双向链表。在 LinkedList 中，由于其内部实现采用双向链表结构，所以可以支持在任意位置进行元素的添加、删除、访问操作。同时，由于其实现了 Deque 接口，因此也可以被视为一个双向队列，支持在队列的两端进行插入、删除操作。
- 虽然 LinkedList 可以被视为双向队列，但是在实际应用中，如果需要高效地进行队列操作，建议使用 ArrayDeque，因为 ArrayDeque 内部采用循环数组的方式实现，比 LinkedList 在队列操作方面更加高效。

## Map

在Java中，Map 是一种数据结构，用于存储一组键值对。具有以下特点：

- 键值对的存储：Map 中存储的是一组键值对，即每个键都对应一个值。可以通过键快速查找到对应的值，从而实现高效的数据访问。
- 键的唯一性：Map 中的键是唯一的，即相同的键只能出现一次。如果添加了相同的键，则后面的键值对会覆盖前面的键值对。
- 值的可重复性：Map 中的值可以重复，即多个键可以对应相同的值。
- 不保证顺序：Map 的实现类在遍历时不保证键值对的顺序，即元素顺序可能会发生变化。

**Map 接口**定义了一系列操作方法，包括：

- put(K key, V value)：将一个键值对添加到 Map 中。
- get(Object key)：根据键获取对应的值。
- containsKey(Object key)：判断 Map 中是否包含指定的键。
- containsValue(Object value)：判断 Map 中是否包含指定的值。
- remove(Object key)：根据键从 Map 中删除一个键值对。
- keySet()：返回一个包含所有键的集合。
- values()：返回一个包含所有值的集合。
- entrySet()：返回一个包含所有键值对的集合。

### HashMap实现类

基于哈希表实现，支持快速添加、删除、查找操作。不保证元素顺序，不支持同步。

### TreeMap实现类

基于红黑树实现，支持排序操作。按键排序，不支持同步。

### LinkedHashMap实现类

基于哈希表和双向链表实现，保证元素顺序与插入顺序一致。不支持同步。

### ConcurrentHashMap实现类

多线程环境下高效的并发哈希表实现。支持高并发访问，采用分段锁机制保证线程安全。
