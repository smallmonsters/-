# 关键字

- [关键字](#关键字)
  - [volatile](#volatile)
  - [public](#public)
  - [private](#private)
    - [修饰构造函数](#修饰构造函数)
  - [protected](#protected)
  - [default](#default)
  - [final](#final)
  - [static](#static)
    - [静态变量（类变量）](#静态变量类变量)
    - [静态块](#静态块)
  - [synchronized](#synchronized)
  - [strictfp](#strictfp)
  - [@Override](#override)

| 访问控制权限 | 同一个类 | 同一个包 | 不同包中的子类 | 其他包中的类 |
| :----------- | :------- | :------- | :------------- | :----------- |
| public       | Yes      | Yes      | Yes            | Yes          |
| protected    | Yes      | Yes      | Yes            |              |
| default      | Yes      | Yes      |                |              |
| private      | Yes      |          |                |              |

## volatile

> [Java中volatile关键字的最全总结](https://cloud.tencent.com/developer/article/1618122)
> [java并发编程基础——同步机制](https://juejin.cn/post/6844903930531414029)
> [java并发编程——内存模型](https://www.jianshu.com/p/b1f7dce224f7)

volatile是Java提供的一种轻量级的同步机制，保证可见性和有序性。可以修饰方法和变量，被volatile修饰的变量后，表示这个变量在不同线程中是共享，编译器与运行时都会注意到这个变量是共享的，因此不会对该变量进行重排序
<!-- TODO: 我怎么知道我写的代码是不是再同一个线程里 -->

## public

公共的，其他类中可见

```java
// class Person
public class Person {
    public String name; // 公共字段，可以被其他类访问
    public int age; // 公共字段，可以被其他类访问
    
    // 构造函数
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 公共方法，可以被其他类访问
    public void introduce() {
        System.out.println("My name is " + name + ", and I am " + age + " years old.");
    }
}
// class Main
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 25);
        person.introduce(); // 输出："My name is Alice, and I am 25 years old."
        System.out.println(person.name); // 输出："Alice"
        System.out.println(person.age); // 输出：25
    }
}

```

## private

- 私有的，本类中可见

```java
// class Person
public class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void introduce() {
        System.out.println("My name is " + name + ", and I am " + age + " years old.");
    }
}
// class Main
public class Main {
  public static void main(String[] args) {
    Person person = new Person("Alice", 25);
    person.introduce(); // 输出："My name is Alice, and I am 25 years old."
    System.out.println(person.name); //报错，
    System.out.println(person.getName()); // 输出："Alice"
    System.out.println(person.getAge()); // 输出：25
  }
}

```

### 修饰构造函数

使用 private 修饰符来限制构造函数的访问权限，使得只有类内部才能调用该构造函数，而外部的代码则无法直接实例化该类。

```java
public class MyClass {
    private MyClass() {
        // 构造函数的实现代码
        System.out.println("调用了构造函数");
    }

    public static void createInstance() {
        MyClass instance = new MyClass();
        // 对实例进行初始化等操作
    }
}

```

## protected
<!-- learned -->

## default
<!-- learned -->

## final
<!-- learned -->

## static

### 静态变量（类变量）

使用static关键字声明的变量是类变量，也称为静态变量。类变量属于类本身，而不是类的任何实例。因此，它们可以在类的任何实例中访问，也可以在类被加载时初始化

### 静态块

静态块是一个代码块，在类被**加载**时执行。它可以用于初始化静态变量

```java
public class MyClass {
   static int count;
   static {
      count = 0;
   }
}

```

## synchronized
<!-- TODO: -->

## strictfp
<!-- TODO: -->

## @Override

@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:
1、可以当注释用,方便阅读；
2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。
