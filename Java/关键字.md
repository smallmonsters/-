# 关键字

- [关键字](#关键字)
  - [volatile](#volatile)
  - [protected](#protected)
  - [default](#default)
  - [private](#private)
  - [final](#final)
  - [static](#static)
    - [静态变量（类变量）](#静态变量类变量)
    - [静态块](#静态块)
  - [synchronized](#synchronized)
  - [strictfp](#strictfp)
  - [@Override](#override)

## volatile

> [Java中volatile关键字的最全总结](https://cloud.tencent.com/developer/article/1618122)
> [java并发编程基础——同步机制](https://juejin.cn/post/6844903930531414029)
> [java并发编程——内存模型](https://www.jianshu.com/p/b1f7dce224f7)

volatile是Java提供的一种轻量级的同步机制，保证可见性和有序性。可以修饰方法和变量，被volatile修饰的变量后，表示这个变量在不同线程中是共享，编译器与运行时都会注意到这个变量是共享的，因此不会对该变量进行重排序
<!-- TODO: 我怎么知道我写的代码是不是再同一个线程里 -->

## protected
<!-- TODO: -->

## default
<!-- TODO: -->

## private
<!-- TODO: -->

## final
<!-- TODO: -->

## static

### 静态变量（类变量）

使用static关键字声明的变量是类变量，也称为静态变量。类变量属于类本身，而不是类的任何实例。因此，它们可以在类的任何实例中访问，也可以在类被加载时初始化

### 静态块

静态块是一个代码块，在类被**加载**时执行。它可以用于初始化静态变量

```java
public class MyClass {
   static int count;
   static {
      count = 0;
   }
}

```

## synchronized
<!-- TODO: -->

## strictfp
<!-- TODO: -->

## @Override

@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:
1、可以当注释用,方便阅读；
2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。
